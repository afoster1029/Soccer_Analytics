---
title: "Final Project MLS"
author: "Alex Foster, Chris Bajek, Webster An"
date: "4/23/2020"
output: html_document
---

```{r setup, include=FALSE}

# Load packages
library(ggplot2)
library(dplyr)
library(janitor)
library(reshape2)
library(tidyr)
library(readr)
library(lubridate)
library(Matrix)
library(DataCombine)
library(rsample)
library(caret)
library(broom)

#plotting and exploring
library(tidyverse) #for plotting and summarizing
library(GGally) #for nice scatterplot matrix 
library(ggridges) #for joy/ridge plots
library(corrplot) #for basic correlation matrix plot
library(naniar) #for exploring missing values
library(pdp) #for partial dependence plots, MARS models

#making things look nice
library(knitr) #for nice tables
library(scales) #for nice labels on graphs
library(gridExtra) #for arranging plots
library(broom) #for nice model output

#data
library(ISLR) #for data
library(moderndive) #for data

#modeling
library(rsample) #for splitting data
library(recipes) #for keeping track of any transformations we do
library(caret) #for modeling
library(leaps) #for variable selection
library(glmnet) #for LASSO
library(earth) #for MARS models
library(vip) #NEW for importance plots
library(rpart.plot)

```
##### Analyze MLS Data with Machine Learning
#### Research Question: Can we predict the number of goals each team will score in a match?
* We intend on using multiple seasons. Our data source has data for the past 8 years. 
* Below we have begun adding explanatory variables and created visualizations for two seasons of matches.


#### Load in the data
```{R}
MLS <- read_csv("USA.csv")

# create datetime objects using lubridate. 
# also initialize variables for each game that will measure home/awayteam goals per game and home/away team goals conceded per game
MLS <- MLS %>%
  mutate(HAGG = 0.0, AAGG = 0.0, HACG = 0.0, AACG = 0.0, HTP=0, ATP = 0,TG = HG + AG, Datetime = dmy(Date),  month = month(Datetime)) %>%
  select(Country, League, Season, Datetime, Home, Away, HG, AG, Res, HAGG, AAGG, AACG, HACG,HTP,ATP,TG, PH, PD, PA)

ggplot(MLS, aes(Season)) + geom_bar() + ylab("Total Games") + ggtitle("MLS Dataset")

```

#### Data Wrangling
* We created a dataframe where each game in the original dataset is represented in two rows. One row for each team. 
  * Season -- MLS season that this match occured
  * Datetime -- lubridate datetime object
  * Team -- team that the row's statistics belong too
  * Opponent -- the other team in the match
  * Goals -- Number of goals the team scored
  * GoalsAllowed -- Number of goals the opponents scored on the team
  * Res -- result of the game, 'A'(away), 'H'(home) or 'D'(draw)
  * AGS -- Average Goals scored per match by the team in matches before this match in a given season 
  * Position -- Teams position in the league prior to this match
  * OpPosition -- Opponents position in the league prior to this match
  * TG -- Total Goals
  * HA -- 'H' or 'A' indicating if the team is the home team or away team
  * TableDiff -- Difference in positions between the two teams. 
  * OpAGC --  Average goals conceded per a match by opponents in matches prior to this one.
  * GoalScCo -- The sum of AGS and OpAGC
* Response variable: Goals
* Explanatory variables: Team, AGS, Position, OpPosition, HA, TableDiff, OpAGC, GoalScCo 


```{r, echo=FALSE}
# Function that computes the table of the season given a certain date in the season.
# Returns a dataframe that provides stats dependent on the progress of the given season 
compute_table <- function(date, df=USA) {
    # Get only the games that are in the same season and occured before the given date. 
    season = year(date)
    df_subset <- df[which(df$Season == season & df$Datetime < date), ] # get games from that season and up to the given data
    # get team names
    names <- unique(df[which(df$Season==season),]$Home)
    # initialize beginning of season table (stats are all zero)
    table <- data.frame("Team" = names, "Points" = matrix(0,length(names)), "GA" = matrix(0,length(names)), "GF" = matrix(0,length(names)), 'GP' = matrix(0,length(names)))
    if (nrow(df_subset) != 0){
        # Loop through each game and update the explanatory varaibles such as GA, GF, GP. All of these values are dependent on the date of the game. 
        for (row in 1:nrow(df_subset)) {
            current_r =df_subset[row, ]
            # Update info for home team
            home <- current_r$Home
            table$GA[which(table$Team == home)] <- table$GA[which(table$Team == home)] + current_r$AG# GA
            table$GF[which(table$Team == home)] <- table$GF[which(table$Team == home)]+current_r$HG# GF
            table$GP[which(table$Team == home)] <- table$GP[which(table$Team == home)]+1
            
            # Update info for away team
            away <- current_r$Away
            table$GA[which(table$Team == away)] <- table$GA[which(table$Team == away)]+current_r$HG# GA
            table$GF[which(table$Team == away)] <- table$GF[which(table$Team == away)]+current_r$AG# GF
            table$GP[which(table$Team == away)] <- table$GP[which(table$Team == away)]+1
            
            # Award points to winner and for ties. 
            if (current_r$Res == 'H'){ # home wins
              table$Points[which(table$Team == home)] <- table$Points[which(table$Team == home)] + 3
            } else if (current_r$Res == 'A'){ # away wins
              table$Points[which(table$Team == away)] <- table$Points[which(table$Team == away)] + 3
            } else { # draw
              table$Points[which(table$Team == home)] <- table$Points[which(table$Team == home)] + 1
              table$Points[which(table$Team == away)] <- table$Points[which(table$Team == away)] + 1
            }
        }
        # compute goal differential
        table <- table %>%
          mutate('GD' = GF - GA)
        # add AGSG column that represents the avg goals scored per game
        table <- table %>%
          mutate(AGSG = GF / GP)
        # add AGCG column that represents the avg goals conceded per game
        table <- table %>%
          mutate(AGCG = GA / GP)
        # Add position column that indicates what place each team is in. 
        table <- table[with(table,order(table$Points, table$GD)),]
        table$Position <- length(names):1
    }
  return(table)
}
```

```{r, echo=FALSE}
# Function computes table for every game and updates the current season stats like Avg goals scored, avg goals conceded and position in the league. 
add_table_stats <- function(df = usa_2012) {
    for (row in 1:nrow(df)){
      game = df[row,]
      # compute table 
      table <- compute_table(game$Datetime, df)
        # add home/away team average stats based on season performance up to that game.
        if (table[1,]$GP != 1){ # if games played is 1 then we don't really want average stats (avoids potential errors)
            if(game$Home %in% table$Team & game$Away %in% table$Team){ # check that both teams are actually in table.
                # home team stats
                df[row,]$HAGG <- table$AGSG[which(table$Team == game$Home)]
                df[row,]$HACG <- table$AGCG[which(table$Team == game$Home)]
                df[row,]$HTP <- table$Position[which(table$Team == game$Home)]
                # away teams stats
                df[row,]$AAGG <- table$AGSG[which(table$Team == game$Away)]
                df[row,]$AACG <- table$AGCG[which(table$Team == game$Away)]
                df[row,]$ATP <- table$Position[which(table$Team == game$Away)]
            }
        }
    }
    return(df)
}
```
 
```{r,echo=FALSE}
# initialize final dataframe with 2012 season
USA_final <- add_table_stats(MLS[which(MLS$Season==2012),])
# loop through all other seasons that aren't 2012 and compute season statistics.
for (season in unique(MLS$Season)){
  print(season)
  if (season != 2012){
    updated_df <- add_table_stats(MLS[which(MLS$Season==season),])
    USA_final <- rbind(USA_final, updated_df)
  }
}

write.csv(USA_final,"USA_final.csv", row.names = TRUE)
```

```{r,echo=FALSE, message=FALSE}
# Read in dataset (avoid long code run)
MLS_df <- read_csv("USA_final.csv",)
MLS_df <- MLS_df[which(MLS_df$PH != 'USA'),]
MLS_df <- subset(MLS_df,select= -c(X1))
```
##### Putting it all together
```{r}
Home <- MLS_df
Home$Country <- NULL
Home$League <- NULL
Home$Date <- NULL
Home$Time <- NULL
# Home$Away <- NULL
Home$AAGG <- NULL
Home$HACG <- NULL
Home <- Home %>% 
  rename(
    Team = Home,
    Opponent = Away,
    Goals = HG,
    GoalsAllowed = AG,
    Position = HTP,
    AGS = HAGG,
    OpAGC = AACG,
    OpPosition = ATP
    )
Home <- cbind(Home, HA = "H")
Away <- MLS_df
Away$Country <- NULL
Away$League <- NULL
Away$Date <- NULL
Away$Time <- NULL
# Away$Home <- NULL
Away$HAGG <- NULL
Away$AACG <- NULL
Away <- Away %>% 
  rename(
    Team = Away,
    Opponent = Home,
    Goals = AG,
    GoalsAllowed = HG,
    Position = ATP,
    AGS = AAGG,
    OpAGC = HACG,
    OpPosition = HTP,
    Opponent = Home
    )
Away <- cbind(Away, HA = "A")
MLS_final <- rbind(Home, Away)

MLS_final[,"Position"] <- sapply(MLS_final[, "Position"], as.numeric)
MLS_final[,"OpPosition"] <- sapply(MLS_final[, "OpPosition"], as.numeric)
MLS_final[,"AGS"] <- sapply(MLS_final[, "AGS"], as.numeric)
MLS_final[,"OpAGC"] <- sapply(MLS_final[, "OpAGC"], as.numeric)
MLS_final <- MLS_final %>%
  mutate(TableDiff = Position - OpPosition,
         GoalDiff = Goals - GoalsAllowed,
         GoalScCo = AGS + OpAGC)
if ('X1' %in% names(MLS_final)){
  MLS_df[ , !(names(MLS_df) %in% c('X1'))]

}

# Accounting for the fact that Atlanta United has two different names "Atlanta United" and "Atlanta Utd"

# Create replacements data frame
Replaces <- data.frame(from = "Atlanta Utd", to = "Atlanta United")

# Replace patterns and return full data frame
MLS_final1 <- FindReplace(data = MLS_final, Var = "Team", replaceData = Replaces,
                     from = "from", to = "to", exact = FALSE)
MLS_final <- MLS_final1
remove(MLS_final1)
MLS_final <- MLS_final %>% 
  mutate(`PH` = as.numeric(`PH`)) %>% 
  mutate(`PD` = as.numeric(`PD`)) %>% 
  mutate(`PA`= as.numeric(`PA`))
head(MLS_final)
```

#### Data Visualizations

```{r}
# Distrbution of goals by season (broken into months)
MLS_final %>% 
  ggplot(aes(x = Goals)) +
  geom_bar(colour = "#0c4c8a") +
  facet_wrap(~Season)+
  theme_minimal() +
  ggtitle("Goals by Season (Broken in to Months)") +
  theme(plot.title = element_text(hjust = 0.5))
```
*The visualization above shows the total number of goals scored by all teams over the months in which a season is played for each season in the data set. One can observe that the first few months have the highest amount of total goals because these are the months in which there is highest concentration of games.* 



```{r}
# Distribution of full time results  by season
MLS_final %>%
  ggplot(aes(x = Res)) +
  geom_bar() +
  scale_fill_hue() +
  facet_wrap(~Season)+
  theme_minimal() +
  ggtitle("Full Time Results by Season") +
  theme(plot.title = element_text(hjust = 0.5))
```
*The graph above depicts full time results as an Away Win (A), Draw (D), or Home Win (H). As we expect the most common result is a home win, seeming to prove that there is such a thing as home field advantage.* 



```{r}
# Total Goals by team
MLS_final %>%
  ggplot(aes(x = Team, y = Goals)) +
  geom_col() +
  scale_fill_hue() +
  theme(axis.text.x = element_text(angle = 60, hjust = 1)) +
  ggtitle("Total Goals by Team") +
  theme(plot.title = element_text(hjust = 0.5))
```
*This plot shows the total number of goals scored by individual teams in the MLS. Total number of goals can be misleading though because some of the teams are much newer than others and haven't had an opportunity to score goals in all of the seasons in our data.* 



```{r}
# Examining average goals scored
MLS_final %>%
  group_by(Team) %>% 
  mutate(avg_goals=AGS/n()) %>% 
  ggplot(aes(x = Team, y = avg_goals)) +
  geom_col() +
  scale_fill_hue() +
  theme(axis.text.x = element_text(angle = 60, hjust = 1)) +
  ylab("Average Goals per Game") +
  ggtitle("Average Goals by Team") +
  theme(plot.title = element_text(hjust = 0.5))
```
*This plot is similar to the previous one except that it examines the average goals scored per game by each team. The Miami team and the Nashville team were just added to the league so it makes sense that they have little to no goal information.* 



```{r}
# Examining relationship between AGS and Position by team
MLS_final %>% 
  ggplot(aes(x=AGS, y=Position)) +
  geom_point(alpha=.5) +
  scale_fill_hue() +
  facet_wrap(~Team)+
  theme_minimal() +
  ggtitle("Average Goals by Table Position") +
  theme(plot.title = element_text(hjust = 0.5))
```
*The plots above show how the average number of goals relates to a teams position in the MLS table. The lower the position on the y-axis the better a team is doing (being 4th in the table is better than 24th). Generally it looks like the trend is that a higher number of average goals means a better position in the table.* 



```{r}
# Number of goals scored by team during home games or away games
MLS_final %>% 
  ggplot(aes(x=HA, y=Goals)) +
  geom_col() +
  scale_fill_hue() +
  facet_wrap(~Team)+
  theme_minimal() +
  ggtitle("Total Goals Scored at Home and Away") +
  theme(plot.title = element_text(hjust = 0.5))
```
*The plot above shows the number of home and away goals each team has scored over the seasons our data includes. Like the results graph show previously, we expect there to be a homefield advantage and this plot shows there is.* 

#### Modeling 
 

Predict Goals Variable

##### Create training/testing set
* Going to have most recent season be testing set.
```{r}
df_modeling <- MLS_final
df_train <- df_modeling[which(df_modeling$Season != 2019),]
df_train <- df_modeling[which(df_train$Season != 2020),] # remove 2020 from training set.
df_test <- df_modeling[which(df_modeling$Season == 2019),]
cat("Training set contains",nrow(df_train), "rows")
cat('\n')
cat("Training set contains",nrow(df_test), "rows")
```



##### Stepwise Selection of Variables
```{r}
set.seed(123) 
split <- trainControl(method = "cv", number = 5)

cv_MLS_all_vars <- train(
  Goals ~ .,
  data = df_train %>% select(-Datetime, -Season, -Res, -TG),
  method = "leapForward", 
  tuneGrid = data.frame(nvmax = 1:61), 
  trControl = split,
  na.action = na.omit
)

cv_MLS_all_vars$results
cv_MLS_all_vars$bestTune
tidy(coef(cv_MLS_all_vars$finalModel,id=60))
```

```{r}
cv_MLS_all_vars$results %>% 
  ggplot() +
  geom_line(aes(x=nvmax,y=RMSE),color="blue") +
  geom_line(aes(x=nvmax,y=RMSE + RMSESD)) +
  geom_line(aes(x=nvmax,y=RMSE - RMSESD))
```



##### OLS
```{r}
set.seed(123) 
split <- trainControl(method = "cv", number = 5)

ols_model <- train(
  Goals ~ Team + Opponent + GoalsAllowed,
  data = df_train,
  method = "lm", 
  trControl = split,
  na.action = na.omit
)
summary(ols_model)
```
*Discussion*






##### Lasso Model 
```{r}

model_stats <- function(data, lev = NULL, model = NULL) {
  
  stats <- defaultSummary(data, lev = lev, model = model)
  
  transf_rmse <- function (pred, obs) {
    sqrt(mean((exp(obs) - exp(pred))^2))
  }
  
  trmse <- transf_rmse(pred = data$pred,
                       obs = data$obs)
  c(tRMSE = trmse, stats)
}

lambda_grid <- 10^seq(-4, -1 , length = 50)
#Credit for Model_stats code goes to Lisa Lendway. 

set.seed(327)
MLS_lasso <- train(
  Goals ~ Team + AGS + Position + OpPosition + HA + TableDiff + OpAGC + GoalScCo,
  data = df_train, 
  method = "glmnet",
  tuneGrid = data.frame(alpha = 1, lambda = lambda_grid),
  trControl = trainControl(method = "cv",
                           number = 5,
                           summaryFunction = model_stats,
                           returnResamp = "all",
                           selectionFunction = "best"),
  na.action = na.omit,
  metric = "RMSE", 
  maximize = FALSE
)

MLS_lasso$results
MLS_lasso$bestTune
MLS_lasso$results$RMSE[1]

set.seed(327)
MLS_lasso_small <- train(
  Goals ~ Team + AGS + Position + OpPosition + HA + TableDiff + OpAGC + GoalScCo,
  data = df_train, 
  method = "glmnet",
  tuneGrid = data.frame(alpha = 1, lambda = lambda_grid),
  trControl = trainControl(method = "cv",
                           number = 5,
                           summaryFunction = model_stats,
                           returnResamp = "all",
                           selectionFunction = "oneSE"),
  na.action = na.omit,
  metric = "RMSE", 
  maximize = FALSE
)

MLS_lasso_small$results
MLS_lasso_small$bestTune
MLS_lasso_small$results$RMSE[47]
best_lambda_small <- MLS_lasso_small$bestTune$lambda
coefficients(MLS_lasso_small$finalModel, s = best_lambda_small)

set.seed(327)
MLS_lasso_small_test <- train(
  Goals ~ Team + AGS + Position + OpPosition + HA + TableDiff + OpAGC + GoalScCo,
  data = df_test, 
  method = "glmnet",
  tuneGrid = data.frame(alpha = 1, lambda = lambda_grid),
  trControl = trainControl(method = "cv",
                           number = 5,
                           summaryFunction = model_stats,
                           returnResamp = "all",
                           selectionFunction = "oneSE"),
  na.action = na.omit,
  metric = "tRMSE", 
  maximize = FALSE
)

MLS_lasso_small_test$results
coefficients(MLS_lasso_small_test$finalModel, s = best_lambda_small)
```
*Discussion* We chose to run two lasso models, one normal lasso model, and one tuned to be the smallest model (the model with largest lambda within one standard error of the best models). Our first model produced an RMSE of 1.174427 and the smaller lasso model had an RMSE of 1.183064. Both of these values are similar to the OLS model, and higher than the Stepwise-Selection RMSE. 

If we examine the coefficients of the smallest model, only 4 terms remain, the largest coefficient being for GoalScCo = 0.029404969. 

#MARS MLS Model

```{r}
set.seed(327)

MLS_mars <- train(
  Goals ~ Team + AGS + Position + OpPosition + HA + TableDiff + OpAGC + GoalScCo,
  data = df_train, 
  method = "earth",
  trControl = trainControl(method = "cv",
                           number = 5,
                           summaryFunction = model_stats,
                           returnResamp = "all"),
                           na.action = na.exclude,
                          
                          
  tuneGrid = data.frame(degree = 1, nprune = 2:8)
)

MLS_mars_best <- train(
  Goals ~ Team + AGS + Position + OpPosition + HA + TableDiff + OpAGC + GoalScCo,
  data = df_train, 
  method = "earth",
  #tuneGrid = data.frame(alpha = 1, lambda = lambda_grid),
  trControl = trainControl(method = "cv",
                           number = 5,
                           summaryFunction = model_stats,
                           returnResamp = "all",
                           selectionFunction = "best"),
                           na.action = na.exclude,
  
  
  tuneGrid = data.frame(degree = 1, nprune = 2:8)
 
)
MLS_mars$results
MLS_mars_best$results


partial(MLS_mars, pred.var = "GoalScCo", grid.resolution = 50) %>%
  autoplot() 

partial(MLS_mars, pred.var = "HA", grid.resolution = 50) %>%
  autoplot() 
```
*Discussion* The output of our Mars models yielded similar results to our previous models. The lowest RMSE of our models occured for both of them at the 4th prune, corresponding to an RMSE of 1.178. The partial dependence plot of GoalScCo indicates a linear relationship between Goals and this variable which is the sum of AGS and OpAGC. 

#MLS Regression Tree

```{r}
set.seed(327)

house_tree <- train(
  mod_rec,
  data = df_train, 
  method = "rpart",
  trControl = trainControl(method = "cv",
                           number = 5,
                           summaryFunction = model_stats,
                           returnResamp = "all"),
  na.action = na.exclude,
  tuneGrid = data.frame(cp = 10^seq(-4, -2 , length = 20))
)

house_tree$results

```

#KNN MLS Model

```{r}
set.seed(327)
MLS_knn <- train(
  Goals ~ Team + AGS + Position + OpPosition + HA + TableDiff + OpAGC + GoalScCo, 
  data = df_train, 
  method = "knn", 
  trControl = trainControl(method = "cv",
                           number = 5,
                           summaryFunction = model_stats,
                           returnResamp = "all"),
  na.action = na.exclude,
  tuneGrid = data.frame(k = c(1:30)))
  

MLS_knn$results
MLS_knn$bestTune$k

MLS_knn$results %>%
  mutate(RMSESE = RMSESD/sqrt(5)) %>%
  select(k,RMSE,RMSESE) %>%
  ggplot(aes(x=k, y=RMSE)) +
  geom_point() +
  geom_pointrange(aes(ymin=RMSE+RMSESE, ymax=RMSE-RMSESE)) +
  geom_line(aes(x=k, y=RMSE), color = "#0c4c8a") +
  geom_hline(yintercept = 1.235700 + 0.02363899, color = "black")
```
*Discussion* 
When we run a KNN model the lowest RMSE, 1.2357, can be observed when k = 15. If we take a look at the the best tune parameter, this confirms that k = 15. However, there could be an argument for a model in which k = 10, as this is the simplest model within one RMSE standard error of k = 15. 